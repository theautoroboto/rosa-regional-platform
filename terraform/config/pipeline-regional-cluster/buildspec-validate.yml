version: 0.2

env:
  shell: bash

phases:
  install:
    commands:
      - echo "Installing dependencies..."
      - yum install -y unzip python3 jq gnupg2
      - pip3 install boto3
      - echo "Installing Terraform..."
      - |
        set -euo pipefail
        TF_VERSION="1.14.3"
        TF_PACKAGE="terraform_${TF_VERSION}_linux_amd64.zip"
        TF_BASE_URL="https://releases.hashicorp.com/terraform/${TF_VERSION}"

        # Download Terraform package and verification files
        echo "Downloading Terraform ${TF_VERSION}..."
        curl -sSfO "${TF_BASE_URL}/${TF_PACKAGE}"
        curl -sSfO "${TF_BASE_URL}/terraform_${TF_VERSION}_SHA256SUMS"
        curl -sSfO "${TF_BASE_URL}/terraform_${TF_VERSION}_SHA256SUMS.sig"

        # Import HashiCorp GPG key
        echo "Importing HashiCorp GPG key..."
        gpg --batch --keyserver keyserver.ubuntu.com --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F || \
        gpg --batch --keyserver keys.openpgp.org --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F || \
        gpg --batch --keyserver pgp.mit.edu --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F

        # Verify GPG signature on SHA256SUMS
        echo "Verifying GPG signature..."
        if ! gpg --batch --verify "terraform_${TF_VERSION}_SHA256SUMS.sig" "terraform_${TF_VERSION}_SHA256SUMS"; then
          echo "❌ GPG signature verification failed"
          exit 1
        fi
        echo "✓ GPG signature verified"

        # Verify checksum of Terraform package
        echo "Verifying SHA256 checksum..."
        if ! grep "${TF_PACKAGE}" "terraform_${TF_VERSION}_SHA256SUMS" | sha256sum -c -; then
          echo "❌ Checksum verification failed"
          exit 1
        fi
        echo "✓ Checksum verified"

        # Install Terraform
        echo "Installing Terraform..."
        unzip -o "${TF_PACKAGE}" -d /tmp/tf-bin
        mv /tmp/tf-bin/terraform /usr/local/bin/

        # Cleanup
        rm -f "${TF_PACKAGE}" "terraform_${TF_VERSION}_SHA256SUMS" "terraform_${TF_VERSION}_SHA256SUMS.sig"

        terraform version
        echo "✓ Terraform installation verified"

  build:
    commands:
      - echo "Validating Regional Cluster Configurations..."
      - |
        set -euo pipefail

        # Function to ensure state bucket exists with proper security settings
        ensure_state_bucket() {
            local BUCKET_NAME=$1
            local BUCKET_REGION=$2
            local TARGET_ACCOUNT=$3

            echo "Ensuring state bucket exists: $BUCKET_NAME in account $TARGET_ACCOUNT"

            # Assume role in target account to create bucket
            TEMP_CREDS=$(aws sts assume-role \
                --role-arn "arn:aws:iam::${TARGET_ACCOUNT}:role/OrganizationAccountAccessRole" \
                --role-session-name "terraform-state-bucket-creation" \
                --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
                --output text)

            export AWS_ACCESS_KEY_ID=$(echo $TEMP_CREDS | awk '{print $1}')
            export AWS_SECRET_ACCESS_KEY=$(echo $TEMP_CREDS | awk '{print $2}')
            export AWS_SESSION_TOKEN=$(echo $TEMP_CREDS | awk '{print $3}')

            # Check if bucket exists
            if ! aws s3api head-bucket --bucket "$BUCKET_NAME" 2>/dev/null; then
                echo "Creating state bucket $BUCKET_NAME in $BUCKET_REGION..."

                if [ "$BUCKET_REGION" == "us-east-1" ]; then
                    aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$BUCKET_REGION"
                else
                    aws s3api create-bucket --bucket "$BUCKET_NAME" --region "$BUCKET_REGION" \
                        --create-bucket-configuration LocationConstraint="$BUCKET_REGION"
                fi

                # Enable versioning
                aws s3api put-bucket-versioning --bucket "$BUCKET_NAME" \
                    --versioning-configuration Status=Enabled

                # Enable encryption
                aws s3api put-bucket-encryption --bucket "$BUCKET_NAME" \
                    --server-side-encryption-configuration \
                    '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'

                # Block public access
                aws s3api put-public-access-block --bucket "$BUCKET_NAME" \
                    --public-access-block-configuration \
                    "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"

                echo "✓ State bucket created and configured"
            else
                echo "✓ State bucket already exists"
            fi

            # Unset assumed role credentials
            unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
        }

        validate_target() {
            local ACCOUNT_ID=$1
            local REGION=$2
            local ALIAS=$3

            echo "===================================================="
            echo "Validating: $ALIAS ($ACCOUNT_ID) in $REGION"
            echo "===================================================="

            local ROLE_ARN="arn:aws:iam::${ACCOUNT_ID}:role/OrganizationAccountAccessRole"

            # Assume role once for all operations
            echo "Assuming role for validation operations..."
            echo "Role ARN: $ROLE_ARN"

            if ! ASSUMED_CREDS=$(aws sts assume-role \
                --role-arn "$ROLE_ARN" \
                --role-session-name "regional-validation" \
                --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
                --output text 2>&1); then
                echo "❌ FAILED: Cannot assume role $ROLE_ARN"
                echo ""
                echo "Error details:"
                echo "$ASSUMED_CREDS"
                echo ""
                echo "Common causes:"
                echo "  • OrganizationAccountAccessRole does not exist in target account"
                echo "  • Trust policy does not allow central account to assume role"
                echo "  • CodeBuild role lacks sts:AssumeRole permission"
                echo ""
                return 1
            fi

            # Export assumed role credentials for all subsequent operations
            export AWS_ACCESS_KEY_ID=$(echo $ASSUMED_CREDS | awk '{print $1}')
            export AWS_SECRET_ACCESS_KEY=$(echo $ASSUMED_CREDS | awk '{print $2}')
            export AWS_SESSION_TOKEN=$(echo $ASSUMED_CREDS | awk '{print $3}')

            # Verify credentials work
            if ! ASSUMED_IDENTITY=$(aws sts get-caller-identity --query 'Account' --output text 2>&1); then
                echo "❌ FAILED: Can assume role but cannot make API calls"
                echo "Error: $ASSUMED_IDENTITY"
                unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
                return 1
            fi

            if [ "$ASSUMED_IDENTITY" != "$ACCOUNT_ID" ]; then
                echo "❌ FAILED: Assumed role in wrong account"
                echo "  Expected: $ACCOUNT_ID"
                echo "  Got: $ASSUMED_IDENTITY"
                unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
                return 1
            fi

            echo "✅ Successfully assumed role in account $ACCOUNT_ID"
            echo ""

            # Build and push platform container image
            echo "Building and pushing platform container image..."
            chmod +x scripts/build-platform-image.sh
            ./scripts/build-platform-image.sh
            echo ""

            # Set Terraform backend and variable configuration
            export TF_VAR_assume_role_arn=$ROLE_ARN
            export TF_STATE_BUCKET="terraform-state-${ACCOUNT_ID}"
            export TF_STATE_KEY="regional-cluster/${ALIAS}.tfstate"
            export TF_STATE_REGION=$REGION

            # Ensure state bucket exists (will use current credentials)
            echo "Ensuring Terraform state bucket exists..."
            if ! aws s3api head-bucket --bucket "$TF_STATE_BUCKET" 2>/dev/null; then
                echo "Creating state bucket $TF_STATE_BUCKET..."

                if [ "$TF_STATE_REGION" == "us-east-1" ]; then
                    aws s3api create-bucket --bucket "$TF_STATE_BUCKET" --region "$TF_STATE_REGION"
                else
                    aws s3api create-bucket --bucket "$TF_STATE_BUCKET" --region "$TF_STATE_REGION" \
                        --create-bucket-configuration LocationConstraint="$TF_STATE_REGION"
                fi

                # Enable versioning
                aws s3api put-bucket-versioning --bucket "$TF_STATE_BUCKET" \
                    --versioning-configuration Status=Enabled

                # Enable encryption
                aws s3api put-bucket-encryption --bucket "$TF_STATE_BUCKET" \
                    --server-side-encryption-configuration \
                    '{"Rules": [{"ApplyServerSideEncryptionByDefault": {"SSEAlgorithm": "AES256"}}]}'

                # Block public access
                aws s3api put-public-access-block --bucket "$TF_STATE_BUCKET" \
                    --public-access-block-configuration \
                    "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"

                echo "✓ State bucket created and configured"
            else
                echo "✓ State bucket already exists"
            fi

            export TF_VAR_region_name=$REGION
            export TF_VAR_app_code="infra"
            export TF_VAR_service_phase="prod"
            export TF_VAR_cost_center="000"
            export TF_VAR_repository_url="https://github.com/${GITHUB_REPO_OWNER}/${GITHUB_REPO_NAME}.git"
            export TF_VAR_repository_branch="${GITHUB_BRANCH:-main}"
            export TF_VAR_api_additional_allowed_accounts="$ACCOUNT_ID"

            # Run terraform operations in subshell (credentials already set above)
            echo "Running Terraform validation..."
            (
                cd terraform/config/regional-cluster

                terraform init \
                    -reconfigure \
                    -backend-config="bucket=$TF_STATE_BUCKET" \
                    -backend-config="key=$TF_STATE_KEY" \
                    -backend-config="region=$TF_STATE_REGION" \
                    -backend-config="use_lockfile=true"

                terraform validate

                terraform plan -out=tfplan

                terraform show -no-color tfplan > plan-summary.txt
                echo "✓ Plan summary saved to plan-summary.txt"
            )

            # Cleanup - unset assumed role credentials
            unset AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN

            echo "✅ Validation complete for $ALIAS"
            echo ""
        }

        # Process Manual Overrides if present
        if [[ -n "$TARGET_ACCOUNT_ID" && -n "$TARGET_REGION" && -n "$TARGET_ALIAS" ]]; then
            echo "Detected Manual Configuration Override."
            validate_target "$TARGET_ACCOUNT_ID" "$TARGET_REGION" "$TARGET_ALIAS"
        fi

        # Process JSON Files filtered by environment
        # Default to integration if TARGET_ENVIRONMENT not set
        FILTER_ENVIRONMENT="${TARGET_ENVIRONMENT:-integration}"
        echo "Filtering regional configurations for environment: $FILTER_ENVIRONMENT"

        for file in deploy/${FILTER_ENVIRONMENT}/*/terraform/regional.json; do
            [ -e "$file" ] || continue

            ACCOUNT_ID=$(jq -r '.account_id // ""' "$file")
            REGION=$(jq -r '.region // ""' "$file")
            ALIAS=$(jq -r '.alias // ""' "$file")

            if [[ -z "$ACCOUNT_ID" || -z "$REGION" || -z "$ALIAS" ]]; then
                echo "Skipping invalid config in $file (missing account_id, region, or alias)"
                continue
            fi

            validate_target "$ACCOUNT_ID" "$REGION" "$ALIAS"
        done

  post_build:
    commands:
      - echo "Validation complete."
      - |
        if [ -f terraform/config/regional-cluster/plan-summary.txt ]; then
          echo "=== Terraform Plan Summary ==="
          cat terraform/config/regional-cluster/plan-summary.txt
        fi

artifacts:
  files:
    - '**/*'

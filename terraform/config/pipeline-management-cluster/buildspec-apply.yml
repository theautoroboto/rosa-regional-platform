version: 0.2

env:
  shell: bash

phases:
  install:
    commands:
      - echo "Installing dependencies..."
      - yum install -y unzip python3 jq gnupg2
      - pip3 install boto3 pyyaml
      - echo "Installing Terraform..."
      - |
        set -euo pipefail
        TF_VERSION="1.14.3"
        TF_PACKAGE="terraform_${TF_VERSION}_linux_amd64.zip"
        TF_BASE_URL="https://releases.hashicorp.com/terraform/${TF_VERSION}"

        # Download Terraform package and verification files
        echo "Downloading Terraform ${TF_VERSION}..."
        curl -sSfO "${TF_BASE_URL}/${TF_PACKAGE}"
        curl -sSfO "${TF_BASE_URL}/terraform_${TF_VERSION}_SHA256SUMS"
        curl -sSfO "${TF_BASE_URL}/terraform_${TF_VERSION}_SHA256SUMS.sig"

        # Import HashiCorp GPG key
        echo "Importing HashiCorp GPG key..."
        gpg --batch --keyserver keyserver.ubuntu.com --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F || \
        gpg --batch --keyserver keys.openpgp.org --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F || \
        gpg --batch --keyserver pgp.mit.edu --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F

        # Verify GPG signature on SHA256SUMS
        echo "Verifying GPG signature..."
        if ! gpg --batch --verify "terraform_${TF_VERSION}_SHA256SUMS.sig" "terraform_${TF_VERSION}_SHA256SUMS"; then
          echo "❌ GPG signature verification failed"
          exit 1
        fi
        echo "✓ GPG signature verified"

        # Verify checksum of Terraform package
        echo "Verifying SHA256 checksum..."
        if ! grep "${TF_PACKAGE}" "terraform_${TF_VERSION}_SHA256SUMS" | sha256sum -c -; then
          echo "❌ Checksum verification failed"
          exit 1
        fi
        echo "✓ Checksum verified"

        # Install Terraform
        echo "Installing Terraform..."
        unzip -o "${TF_PACKAGE}" -d /tmp/tf-bin
        mv /tmp/tf-bin/terraform /usr/local/bin/

        # Cleanup
        rm -f "${TF_PACKAGE}" "terraform_${TF_VERSION}_SHA256SUMS" "terraform_${TF_VERSION}_SHA256SUMS.sig"

        terraform version
        echo "✓ Terraform installation verified"

  pre_build:
    commands:
      - echo "=========================================="
      - echo "Pre-flight Setup"
      - echo "=========================================="
      - |
        set -euo pipefail

        # Get central account ID for state bucket
        CENTRAL_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export CENTRAL_ACCOUNT_ID
        echo "Central Account: $CENTRAL_ACCOUNT_ID"

        # Detect S3 state bucket region (bucket is in central account)
        TF_STATE_BUCKET="terraform-state-${CENTRAL_ACCOUNT_ID}"
        BUCKET_REGION=$(aws s3api get-bucket-location --bucket "$TF_STATE_BUCKET" --region us-east-1 --query LocationConstraint --output text)
        if [ "$BUCKET_REGION" == "None" ] || [ "$BUCKET_REGION" == "null" ] || [ -z "$BUCKET_REGION" ]; then BUCKET_REGION="us-east-1"; fi
        export TF_STATE_REGION=$BUCKET_REGION
        echo "State Bucket Region: $TF_STATE_REGION"
        echo ""

        # Validate required environment variables
        if [[ -z "$TARGET_ACCOUNT_ID" || -z "$TARGET_REGION" || -z "$TARGET_ALIAS" ]]; then
            echo "❌ ERROR: Required environment variables not set"
            echo "   TARGET_ACCOUNT_ID: ${TARGET_ACCOUNT_ID}"
            echo "   TARGET_REGION: ${TARGET_REGION}"
            echo "   TARGET_ALIAS: ${TARGET_ALIAS}"
            exit 1
        fi

        echo "Target Account: $TARGET_ACCOUNT_ID"
        echo "Target Region: $TARGET_REGION"
        echo "Target Alias: $TARGET_ALIAS"

        # Assume role for AWS CLI operations (secret creation) AND Terraform
        # NOTE: We keep manual assume role here because this buildspec uses AWS CLI
        # to create secrets in the target account before Terraform runs
        if [ "$TARGET_ACCOUNT_ID" != "$CENTRAL_ACCOUNT_ID" ]; then
            ROLE_ARN="arn:aws:iam::${TARGET_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
            echo "Assuming role: $ROLE_ARN"

            if ! TEMP_CREDS=$(aws sts assume-role \
                --role-arn "$ROLE_ARN" \
                --role-session-name "pipeline-apply-${TARGET_ALIAS}" \
                --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
                --output text 2>&1); then
                echo "❌ ERROR: Failed to assume role $ROLE_ARN"
                echo "Error: $TEMP_CREDS"
                exit 1
            fi

            # Export credentials for AWS CLI and Terraform
            export AWS_ACCESS_KEY_ID=$(echo "$TEMP_CREDS" | awk '{print $1}')
            export AWS_SECRET_ACCESS_KEY=$(echo "$TEMP_CREDS" | awk '{print $2}')
            export AWS_SESSION_TOKEN=$(echo "$TEMP_CREDS" | awk '{print $3}')

            # Verify
            ASSUMED_ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
            if [ "$ASSUMED_ACCOUNT" != "$TARGET_ACCOUNT_ID" ]; then
                echo "❌ ERROR: Assumed wrong account"
                exit 1
            fi

            echo "✅ Assumed role in account $TARGET_ACCOUNT_ID"
        else
            echo "✅ Target account same as central - using current credentials"
        fi
        echo ""

  build:
    commands:
      - echo "Processing Management Cluster Configurations..."
      - |
        set -euo pipefail

        echo "Using credentials from pre_build phase"
        echo "  Current identity: $(aws sts get-caller-identity --query Arn --output text)"
        echo ""

        # Export Variables for Makefile / Terraform Backend
        # State is stored in the Central Account, but we use the Management Alias in the key
        export TF_STATE_BUCKET="terraform-state-${CENTRAL_ACCOUNT_ID}"
        export TF_STATE_KEY="management-cluster/${TARGET_ALIAS}.tfstate"


        # Export Terraform Variables for Management Cluster
        export TF_VAR_region="${TARGET_REGION}"
        export TF_VAR_app_code="${APP_CODE}"
        export TF_VAR_service_phase="${SERVICE_PHASE}"
        export TF_VAR_cost_center="${COST_CENTER}"
        export TF_VAR_cluster_id="${CLUSTER_ID}"
        export TF_VAR_regional_aws_account_id="${REGIONAL_AWS_ACCOUNT_ID}"
        export TF_VAR_repository_url="${REPOSITORY_URL}"
        export TF_VAR_repository_branch="${REPOSITORY_BRANCH}"

        # Skip ArgoCD validation for infra provisioning
        export SKIP_ARGOCD_VALIDATION=true

        # Create placeholder Maestro agent secrets in target account (using assumed credentials from pre_build)
        echo "Ensuring Maestro agent secrets exist in account ${TARGET_ACCOUNT_ID}..."

        for SECRET_NAME in "maestro/agent-cert" "maestro/agent-config"; do
            # Check if secret exists
            if ! aws secretsmanager describe-secret --secret-id "$SECRET_NAME" --region ${TARGET_REGION} 2>/dev/null; then

                echo "Creating placeholder secret: $SECRET_NAME"
                if ! CREATE_OUTPUT=$(aws secretsmanager create-secret \
                    --name "$SECRET_NAME" \
                    --description "Placeholder secret for Maestro agent (created by buildspec)" \
                    --secret-string '{"placeholder":true}' \
                    --region ${TARGET_REGION} 2>&1); then

                    # Check if failure is due to secret already existing (race condition)
                    if echo "$CREATE_OUTPUT" | grep -q "ResourceExistsException"; then
                        echo "Secret $SECRET_NAME already exists (created concurrently)"
                    else
                        echo "❌ Failed to create secret $SECRET_NAME"
                        echo "Error: $CREATE_OUTPUT"
                        exit 1
                    fi
                else
                    echo "✓ Created secret $SECRET_NAME"
                fi
            else
                echo "Secret $SECRET_NAME already exists"
            fi
        done

        echo "Maestro agent placeholder secrets verified"

        # Run Infrastructure Provision (without ArgoCD bootstrap)
        echo "Running Infrastructure Provisioning..."
        make pipeline-provision-management
        PROVISION_STATUS=$?

        if [ $PROVISION_STATUS -ne 0 ]; then
            echo "❌ Infrastructure provisioning failed with exit code $PROVISION_STATUS"
            exit $PROVISION_STATUS
        fi

        echo "✅ Infrastructure provisioning complete."

  post_build:
    commands:
      - echo "Infrastructure deployment complete."
      - echo "ArgoCD bootstrap will run in the next pipeline stage."

artifacts:
  files:
    - '**/*'

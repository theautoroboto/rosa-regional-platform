version: 0.2

env:
  shell: bash

phases:
  install:
    commands:
      - echo "Installing dependencies for ArgoCD bootstrap..."
      - yum install -y jq gnupg2
      - chmod +x scripts/bootstrap-argocd.sh
      - echo "Installing kubectl..."
      - |
        set -euo pipefail
        KUBECTL_VERSION="v1.31.0"

        # Download kubectl binary and checksum
        echo "Downloading kubectl ${KUBECTL_VERSION}..."
        curl -sSfLO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
        curl -sSfLO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl.sha256"

        # Verify checksum
        echo "Verifying kubectl checksum..."
        if ! echo "$(cat kubectl.sha256)  kubectl" | sha256sum -c -; then
          echo "❌ kubectl checksum verification failed"
          exit 1
        fi
        echo "✓ kubectl checksum verified"

        # Install kubectl
        chmod +x kubectl
        mv kubectl /usr/local/bin/
        rm -f kubectl.sha256

        kubectl version --client
        echo "✓ kubectl installation verified"
      - echo "Installing Terraform (needed to read outputs)..."
      - |
        set -euo pipefail
        TF_VERSION="1.14.3"
        TF_PACKAGE="terraform_${TF_VERSION}_linux_amd64.zip"
        TF_BASE_URL="https://releases.hashicorp.com/terraform/${TF_VERSION}"

        # Download Terraform package and verification files
        echo "Downloading Terraform ${TF_VERSION}..."
        curl -sSfO "${TF_BASE_URL}/${TF_PACKAGE}"
        curl -sSfO "${TF_BASE_URL}/terraform_${TF_VERSION}_SHA256SUMS"
        curl -sSfO "${TF_BASE_URL}/terraform_${TF_VERSION}_SHA256SUMS.sig"

        # Import HashiCorp GPG key
        echo "Importing HashiCorp GPG key..."
        gpg --batch --keyserver keyserver.ubuntu.com --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F || \
        gpg --batch --keyserver keys.openpgp.org --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F || \
        gpg --batch --keyserver pgp.mit.edu --recv-keys \
          C874011F0AB405110D02105534365D9472D7468F

        # Verify GPG signature on SHA256SUMS
        echo "Verifying GPG signature..."
        if ! gpg --batch --verify "terraform_${TF_VERSION}_SHA256SUMS.sig" "terraform_${TF_VERSION}_SHA256SUMS"; then
          echo "❌ GPG signature verification failed"
          exit 1
        fi
        echo "✓ GPG signature verified"

        # Verify checksum of Terraform package
        echo "Verifying SHA256 checksum..."
        if ! grep "${TF_PACKAGE}" "terraform_${TF_VERSION}_SHA256SUMS" | sha256sum -c -; then
          echo "❌ Checksum verification failed"
          exit 1
        fi
        echo "✓ Checksum verified"

        # Install Terraform
        echo "Installing Terraform..."
        unzip -o "${TF_PACKAGE}" -d /tmp/tf-bin
        mv /tmp/tf-bin/terraform /usr/local/bin/

        # Cleanup
        rm -f "${TF_PACKAGE}" "terraform_${TF_VERSION}_SHA256SUMS" "terraform_${TF_VERSION}_SHA256SUMS.sig"

        terraform version
        echo "✓ Terraform installation verified"

  pre_build:
    commands:
      - echo "=========================================="
      - echo "Pre-flight Setup"
      - echo "=========================================="
      - |
        set -euo pipefail

        # Validate required environment variables
        if [[ -z "${TARGET_ACCOUNT_ID:-}" || -z "${TARGET_REGION:-}" || -z "${TARGET_ALIAS:-}" ]]; then
            echo "❌ ERROR: Required environment variables not set"
            echo "   TARGET_ACCOUNT_ID: ${TARGET_ACCOUNT_ID:-not set}"
            echo "   TARGET_REGION: ${TARGET_REGION:-not set}"
            echo "   TARGET_ALIAS: ${TARGET_ALIAS:-not set}"
            exit 1
        fi

        # Get central account ID BEFORE assuming role
        CENTRAL_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
        export CENTRAL_ACCOUNT_ID

        # Detect S3 state bucket region BEFORE assuming role (bucket is in central account)
        TF_STATE_BUCKET="terraform-state-${CENTRAL_ACCOUNT_ID}"
        BUCKET_REGION=$(aws s3api get-bucket-location --bucket "$TF_STATE_BUCKET" --region us-east-1 --query LocationConstraint --output text)
        if [ "$BUCKET_REGION" == "None" ] || [ "$BUCKET_REGION" == "null" ] || [ -z "$BUCKET_REGION" ]; then BUCKET_REGION="us-east-1"; fi
        export TF_STATE_REGION=$BUCKET_REGION

        echo "Configuration:"
        echo "  Central Account: $CENTRAL_ACCOUNT_ID"
        echo "  Target Account: $TARGET_ACCOUNT_ID"
        echo "  Target Region: $TARGET_REGION"
        echo "  Target Alias: $TARGET_ALIAS"
        echo "  State Bucket Region: $TF_STATE_REGION"
        echo ""

        # Save central account credentials before assuming role
        # These will be restored later for Terraform backend access
        SAVE_AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID:-}"
        SAVE_AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY:-}"
        SAVE_AWS_SESSION_TOKEN="${AWS_SESSION_TOKEN:-}"

        # Prepare target account credentials for target-specific operations (ECR, EKS, ECS)
        # NOTE: We assume role only for target account operations, then restore central creds for Terraform
        if [ "$TARGET_ACCOUNT_ID" != "$CENTRAL_ACCOUNT_ID" ]; then
            ROLE_ARN="arn:aws:iam::${TARGET_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
            echo "Assuming role for target account operations: $ROLE_ARN"

            if ! TEMP_CREDS=$(aws sts assume-role \
                --role-arn "$ROLE_ARN" \
                --role-session-name "pipeline-bootstrap-${TARGET_ALIAS}" \
                --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
                --output text 2>&1); then
                echo "❌ ERROR: Failed to assume role $ROLE_ARN"
                echo "Error: $TEMP_CREDS"
                exit 1
            fi

            # Store assumed credentials for use in build phase (target account operations)
            export TARGET_AWS_ACCESS_KEY_ID=$(echo "$TEMP_CREDS" | awk '{print $1}')
            export TARGET_AWS_SECRET_ACCESS_KEY=$(echo "$TEMP_CREDS" | awk '{print $2}')
            export TARGET_AWS_SESSION_TOKEN=$(echo "$TEMP_CREDS" | awk '{print $3}')

            # Verify the assumed role credentials work
            ASSUMED_ACCOUNT=$(AWS_ACCESS_KEY_ID="$TARGET_AWS_ACCESS_KEY_ID" \
                              AWS_SECRET_ACCESS_KEY="$TARGET_AWS_SECRET_ACCESS_KEY" \
                              AWS_SESSION_TOKEN="$TARGET_AWS_SESSION_TOKEN" \
                              aws sts get-caller-identity --query Account --output text)
            if [ "$ASSUMED_ACCOUNT" != "$TARGET_ACCOUNT_ID" ]; then
                echo "❌ ERROR: Assumed wrong account. Expected $TARGET_ACCOUNT_ID, got $ASSUMED_ACCOUNT"
                exit 1
            fi

            echo "✅ Assumed role in account $TARGET_ACCOUNT_ID (credentials saved for target operations)"
        else
            echo "✅ Target account same as central - using current credentials for both operations"
            # For same-account deployments, use current credentials for both
            export TARGET_AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID:-}"
            export TARGET_AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY:-}"
            export TARGET_AWS_SESSION_TOKEN="${AWS_SESSION_TOKEN:-}"
        fi
        echo ""

        # Pass target account to Terraform for consistency
        export TF_VAR_target_account_id="${TARGET_ACCOUNT_ID}"
        export TF_VAR_target_alias="${TARGET_ALIAS}"

        # Build platform image (uses target account credentials to push to target ECR)
        echo "Building platform image (if needed)..."
        AWS_ACCESS_KEY_ID="$TARGET_AWS_ACCESS_KEY_ID" \
        AWS_SECRET_ACCESS_KEY="$TARGET_AWS_SECRET_ACCESS_KEY" \
        AWS_SESSION_TOKEN="$TARGET_AWS_SESSION_TOKEN" \
        ./scripts/build-platform-image.sh
        echo ""

  build:
    commands:
      - echo "=========================================="
      - echo "ArgoCD Bootstrap for Management Cluster"
      - echo "=========================================="
      - |
        set -euo pipefail

        echo "Bootstrapping Management Cluster: ${TARGET_ALIAS}"
        echo "  Account: ${TARGET_ACCOUNT_ID}"
        echo "  Region: ${TARGET_REGION}"
        echo "  Environment: ${TARGET_ENVIRONMENT:-integration}"
        echo ""

        # Restore central account credentials for Terraform backend access
        echo "Restoring central account credentials for Terraform backend access..."
        export AWS_ACCESS_KEY_ID="${SAVE_AWS_ACCESS_KEY_ID}"
        export AWS_SECRET_ACCESS_KEY="${SAVE_AWS_SECRET_ACCESS_KEY}"
        export AWS_SESSION_TOKEN="${SAVE_AWS_SESSION_TOKEN}"

        # Verify we're back to central account
        CURRENT_ACCOUNT=$(aws sts get-caller-identity --query Account --output text)
        echo "Current account: $CURRENT_ACCOUNT (central: $CENTRAL_ACCOUNT_ID)"
        echo ""

        # Configure Terraform region via environment variable (HashiCorp recommended approach)
        export TF_VAR_region="${TARGET_REGION}"

        # Configure Terraform backend (state in central account, region detected in pre_build)
        export TF_STATE_BUCKET="terraform-state-${CENTRAL_ACCOUNT_ID}"
        export TF_STATE_KEY="management-cluster/${TARGET_ALIAS}.tfstate"


        echo "Terraform backend:"
        echo "  Bucket: $TF_STATE_BUCKET (central account: $CENTRAL_ACCOUNT_ID)"
        echo "  Key: $TF_STATE_KEY"
        echo "  Region: $TF_STATE_REGION"
        echo ""

        # Initialize Terraform (uses central account credentials for S3 backend)
        echo "Initializing Terraform..."
        cd terraform/config/management-cluster
        terraform init -reconfigure \
            -backend-config="bucket=${TF_STATE_BUCKET}" \
            -backend-config="key=${TF_STATE_KEY}" \
            -backend-config="region=${TF_STATE_REGION}" \
            -backend-config="use_lockfile=true"
        cd ../../..

        # Bootstrap ArgoCD
        # The script reads terraform outputs with central creds, then assumes role internally for ECS/EKS
        echo "Bootstrapping ArgoCD..."

        # Initialize ENVIRONMENT with safe fallbacks (handles both ENVIRONMENT and TARGET_ENVIRONMENT)
        ENVIRONMENT="${ENVIRONMENT:-${TARGET_ENVIRONMENT:-}}"

        # Validate all required environment variables are set (using safe parameter expansion)
        if [[ -z "${ENVIRONMENT:-}" ]]; then
            echo "❌ ERROR: ENVIRONMENT variable not set"
            exit 1
        fi
        if [[ -z "${TARGET_ALIAS:-}" ]]; then
            echo "❌ ERROR: TARGET_ALIAS variable not set"
            exit 1
        fi
        if [[ -z "${TARGET_REGION:-}" ]]; then
            echo "❌ ERROR: TARGET_REGION variable not set"
            exit 1
        fi

        # Export standardized environment variables for bootstrap script
        # The script expects: ENVIRONMENT, REGION_ALIAS, AWS_REGION
        export ENVIRONMENT="${ENVIRONMENT}"
        export REGION_ALIAS="${TARGET_ALIAS}"
        export AWS_REGION="${TARGET_REGION}"

        # Set ASSUME_ROLE_ARN for cross-account bootstrap (if needed)
        # The script will read terraform outputs with current (central) creds,
        # then assume this role for ECS/EKS operations
        if [ "$TARGET_ACCOUNT_ID" != "$CENTRAL_ACCOUNT_ID" ]; then
            export ASSUME_ROLE_ARN="arn:aws:iam::${TARGET_ACCOUNT_ID}:role/OrganizationAccountAccessRole"
            echo "Bootstrap will assume role for target account operations: $ASSUME_ROLE_ARN"
        fi

        echo "Bootstrap environment configuration:"
        echo "  ENVIRONMENT: ${ENVIRONMENT}"
        echo "  REGION_ALIAS: ${REGION_ALIAS}"
        echo "  AWS_REGION: ${AWS_REGION}"
        echo ""

        # Call bootstrap script with central account credentials (for terraform output reading)
        # The script will internally assume ASSUME_ROLE_ARN for ECS/EKS operations
        scripts/bootstrap-argocd.sh management-cluster

        echo "✅ ArgoCD bootstrap complete!"
